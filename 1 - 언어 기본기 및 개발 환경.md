# 1. 언어 기본기 및 개발 환경
### 파일 구조 및 빌드 과정

- Java의 경우
    - `.java` 파일에 정의부 및 구현부를 한 번에 작성
    - IDE를 사용해 빌드 시 컴파일러가 `.java` 파일을 `.class` 파일로 컴파일
    - 컴파일된 `.class` 파일은 JVM(Java Virtual Machine)이 알아서 해석하고 실행
- C++의 경우
    - 정의부는 `.h`, 구현부는 `.cpp`에 작성 (정의 후 구현을 할 수 있음)
    - 1\) 빌드 시, 컴파일 전 전처리 단계를 거침
    - 전처리 단계에는 전처리 지시문을 처리
        - `#include` 파일 내용 붙여넣기
        - `#define` 상수 바꿔치기
        - `#ifdef`문 조건에 따라 추가/제거
        - 등등...
    - 2\) 전처리 이후에는 컴파일러가 `.cpp` 파일을  `.o`(오브젝트) 파일로 컴파일
        - 여기서 중요한 것은 `.h`는 컴파일 하지 않음
        - 그 이유는 전처리 결과물이 이미 `.h`가 합쳐진 하나의 **완전한 소스**이기 때문
    - 3\) 컴파일된 `.o` 파일을 링킹하면 각각 따로 작성된 파일을 한번에 읽어 `.exe` 등의 실행 파일을 생성
    - 해당 실행 파일을 통해 OS가 네이티브 코드 직접 실행
    - 이 말은 즉슨, C++은 JVM과 같은 가상 머신이 없이 OS가 직접 동작한다는 것

### 이름 공간 (namespace)
- 처음에는 클래스명과 헷갈렸지만, 절대 클래스와 동일한 것도 비슷한 것도 아님!
- 사실 Java의 전역 변수는 전역 변수가 아닌 클래스 변수 (무조건 클래스 내에 정의)
- 하지만 C++은 정말 말그대로 전역(Global) 변수 및 함수를 만들 수 있다
- 여러 파일을 include하는 과정에서 같은 이름이 생길 수 밖에 없음
- 이를 해결하기 위해 namespace를 사용하면, 같은 전역 변수여도 namespace에 따른 구분이 가능!
- 모든 전역 함수, 클래스, enum, 변수 등에 대한 이름은 namespace로 구분이 가능
```cpp
namespace name1 {
    int foo();
}

namespace name2 {
    int foo();
}

int main() {
    // 두 메서드는 전역 변수이지만, namespace에 따라 다른 메서드가 불린다!
    int a = name1::foo();
    int b = name2::foo();
}
```

### 기본 자료형
- 위에서 설명했듯, 컴파일로 만들어진 실행 파일은 JVM과 같은 가상 머신이 아닌 OS가 직접 동작
- 그로 인해 신기하게도... 운영체제 및 CPU 비트에 따라 기본 타입의 크기가 바뀔 수 있음!
- C++은 각 기본 자료형의 최소 크기만을 보장함 (정확한 크기 지정 X)
- 이로 인해, Java 개발자들은 낯선 `<cstdint>`의 정수형을 사용하는 것을 습관으로 할 것
    - `<cstdint>`는 확정된 크기를 가진 정수형을 제공
    - `int8_t`, `uint32_t` 등의 자료형이 `<cstdint>`에서 제공하는 자료형
- 각 타입이 확정된 크기를 가지면 오버플로우나 값 손실과 같은 데이터 바이트 문제를 야기하지 않음
- 또한, unsigned 정수형을 사용할 수 있어서 부호 유무를 명시 가능
- 환경에 구애받지 않도록 `<cstdint>`를 사용하자....

#### C++ 표준에서 보장하는 최소 크기
|타입|최소 크기|비고|
|:-:|:-:|-|
|bool|1 byte||
|char|1 byte|char는 무조건 1 byte|
|short|2 bytes||
|int|2 bytes||
|long|4 bytes||
|long long|8 bytes|C++ 11부터 사용|
|float|4 bytes||
|double|8 bytes||